var random=()=>crypto.getRandomValues(new Uint32Array(1))[0]/2**32+"";function randomBytes(e){var o="";for(let t=0;t<e;t++)o+=random()[5];return o}class Client{#e=!1;#o={on:{get:{},say:{}},getPromises:{}};constructor(e,o){this.#e=new WebSocket(e),this.#e.onclose=e=>{this.onclose(e)},this.#e.onerror=e=>{this.onerror(e)},this.#e.onopen=()=>{o&&this.#t("params",!1,o,!1),this.onopen()},this.#e.onmessage=e=>{this.#s(e)}}getState(){return this.#e.readyState}close(){this.#e.close()}onSay(e,o,t=!0){t||!this.#o.on.say[e]?this.#o.on.say[e]=[o]:this.#o.on.say[e].push(o)}onGet(e,o){this.#o.on.get[e]=o}say(e,o){this.#t("say",e,o,!1)}get(e,o){var t=randomBytes(8);return new Promise((s=>{this.#o.getPromises[t]=e=>{delete this.#o.getPromises[t],s(e)},this.#t("get",e,o,t)}))}#s({data:e}){try{e=JSON.parse(e);if("say"==e?.method&&e?.key)this.#o.on.say?.[e.key]&&this.#o.on.say[e.key].forEach((o=>o(e?.cont)));else if("get"==e?.method&&e?.key&&e?.id){const t=o=>{this.#t("getback",!1,o,e.id)};if(!this.#o.on.get[e?.key])return t("not found");var o=this.#o.on.get[e?.key](e?.cont);o instanceof Promise?o.then((e=>t(e))):t(o)}else"getback"==e?.method&&e?.id&&this.#o.getPromises?.[e.id]&&this.#o.getPromises?.[e.id]?.(e?.cont)}catch(e){console.log(e)}}#t(e,o,t,s){var n={method:e,cont:t};o&&(n.key=o),s&&(n.id=s),this.#e.send(JSON.stringify(n))}onclose(){}onopen(){}onerror(){}onend(){}}export default Client;